package io.github.dissonantau.veadotubetouchportalplugin

import com.google.gson.JsonObject
import io.github.oshai.kotlinlogging.KotlinLogging
import java.util.concurrent.atomic.AtomicBoolean

import com.christophecvb.touchportal.TouchPortalPlugin
import com.christophecvb.touchportal.annotations.*
import com.christophecvb.touchportal.helpers.PluginHelper
import com.christophecvb.touchportal.model.*

import io.github.dissonantau.veadotubetouchportalplugin.data.VeadoConnectionData
import io.github.dissonantau.veadotubetouchportalplugin.data.VtState

import io.github.dissonantau.bleatkan.connection.Connection
import io.github.dissonantau.bleatkan.connection.ConnectionError
import io.github.dissonantau.bleatkan.connection.ConnectionListener
import io.github.dissonantau.bleatkan.instance.InstancesListener
import io.github.dissonantau.bleatkan.instance.Instance
import io.github.dissonantau.bleatkan.instance.InstanceID
import io.github.dissonantau.bleatkan.instance.InstancesManager
import io.github.dissonantau.bleatkan.message.VtRequest
import io.github.dissonantau.bleatkan.message.ResultMessage
import io.github.dissonantau.bleatkan.message.ResultPayload.ResultPayloadState as BleatkanStatePeek
import io.github.dissonantau.bleatkan.message.ResultPayload.ResultPayloadStateList as BleatkanStateList
import io.github.dissonantau.bleatkan.message.ResultPayload.ResultPayloadPng as BleatkanStateThumbnail


@Suppress("unused")
@Plugin(version = BuildConfig.VERSION_CODE, colorDark = "#5c1c1c", colorLight = "#822727", name = "Veadotube Plugin")
class VeadoTouchPlugin(parallelizeActions: Boolean) :
    TouchPortalPlugin(parallelizeActions), TouchPortalPlugin.TouchPortalPluginListener,
    InstancesListener, ConnectionListener {


    companion object {
        /** Class Logger */
        @JvmStatic
        private val LOGGER =
            KotlinLogging.logger { TouchPortalPlugin::class.java.name }

        /**
         * Avatar State String RegEx
         *
         * Strings generated by [onUpdateAvatarStateList] are formatted "name (id)" and sent to Touch Portal
         *
         * This RegEx will extract the Name and ID to named groups, with space between Name and ID, and extra brackets excluded
         */
        @JvmStatic
        private val avatarStateRegex = """(?<name>.*?)?\s*\((?<id>\w+)\)""".toRegex()


        /** Veadotube Plugin Object */
        @JvmStatic
        private lateinit var veadotubePlugin: VeadoTouchPlugin

        /** Set Enabled when shutting down to prevent doubling up */
        @JvmStatic
        private var pluginClosing = AtomicBoolean(false)

        @JvmStatic
        fun main(args: Array<String>) {
            LOGGER.debug { "Veadotube Plugin Launched with ${args.size} args: ${args.toList()}" }

            if (args.size == 1) {

                if (PluginHelper.COMMAND_START == args[0]) {
                    LOGGER.info { "Veadotube Plugin Starting" }

                    veadotubePlugin = VeadoTouchPlugin(true)

                    setUpShutdownHook()

                    // Initialize the Plugin (by lazy will execute when we interact with the val)
                    veadotubePlugin.initializePlugin()

                }

            }

        }

        @JvmStatic
        private fun setUpShutdownHook() {
            Runtime.getRuntime().addShutdownHook(object : Thread() {
                override fun run() {
                    LOGGER.info { "Plugin Shutting Down" }
                    // Start Shutdown
                    veadotubePlugin.shutdown()
                }
            })

        }

    }


    private fun initializePlugin() {
        LOGGER.trace { "initializePlugin: Start" }

        // Initiate the connection with the Touch Portal Plugin System
        val connectedPairedAndListening = connectThenPairAndListen(this)


        if (connectedPairedAndListening) {
            LOGGER.info { "Plugin with ID[${VeadoTouchPluginConstants.ID}] Connected and Paired!" }

        } else {
            LOGGER.error { "Failed to Connect and Pair with Touch Portal" }
            throw IllegalStateException("Failed to Connect and Pair with Touch Portal")
        }

        LOGGER.trace { "initializePlugin: Done" }
    }


    /* Touch Portal Categories */

    @Suppress("unused")
    enum class Categories {
        /**
         * Category definition example
         */
        @Category(
            name = "Veadotube - Primary Instance",
            imagePath = "images/icon-24.png"
        )
        PrimaryInstance

    }


    /* Touch Portal Settings Panel */
    /**
     * Setting - Show # of connected instances
     */
    @Setting(name = "# of Connected Instances", defaultValue = "0", isReadOnly = true)
    private var settingVeadoInstanceCount: String = "0"

    /**
     * Setting - Show Primary Instance Address
     */
    @Setting(name = "Primary Instance Address", defaultValue = "Plugin Starting", isReadOnly = true)
    private var settingVeadoPrimaryInstanceServer: String = "Plugin Starting"

    /**
     * Setting - Show Primary Instance Name
     */
    @Setting(name = "Primary Instance Name", defaultValue = "Plugin Starting", isReadOnly = true)
    private var settingVeadoPrimaryInstanceName: String = "Plugin Starting"

    /**
     * Setting - Primary Instance Name Overwrite
     */
    @Setting(name = "Primary Instance Name Override (Leave Blank to Disable)", defaultValue = "")
    private var settingVeadoPrimaryInstanceNameOverride: String = ""

    /**
     * Setting - Primary Instance Name Overwrite Existing Value
     *
     * Need to use this to know what the old/existing value is due to TP SDK replacing the setting automatically,
     * bypassing Kotlin Set and not allowing a comparison of old vs new
     */
    private var settingVeadoPrimaryInstanceNameOverrideExisting: String = ""

    /**
     * Setting - Auto Request Current State Thumbnail
     *
     * Enabled/Disabled (Currently Text due to v6 API - switch to Switch in v10)
     */
    @Setting(name = "Auto Request Current State Thumbnail (Enabled/Disabled)", defaultValue = "disabled")
    private var settingVeadoAutoRequestThumbnail: String = "disabled"


    /**
     * Setting - Auto Request Current State Thumbnail Existing Value
     *
     * Enabled/Disabled (Currently Text due to v6 API - switch to Switch in v10)
     */
    private var settingVeadoAutoRequestThumbnailExisting: String = "disabled"

    /**
     * Setting - Auto Request Current State Thumbnail
     *
     * Enabled/Disabled (Currently Text due to v6 API - switch to Switch in v10)
     */
    private var settingVeadoAutoRequestThumbnailEnabled = false

    /* Touch Portal States, Events, etc. */
    /**
     * Current Avatar State - `Name` (`ID`) Format
     */
    @State(
        desc = "Current Avatar State - Name & ID",
        defaultValue = "Not Connected",
        categoryId = "PrimaryInstance",
        id = "currentAvatarState"
    )
    //    @Event(
    //        name = "On Avatar State Changed (List)",
    //        valueChoices = ["Not Connected"],
    //        format = "When Avatar State becomes \$val", id = "currentAvatarState"
    //    )
    private var stateCurrentAvatarState: String = "Not Connected"


    /**
     * Current Avatar State ID
     */
    @State(
        desc = "Current Avatar State - ID",
        defaultValue = "Not Connected",
        categoryId = "PrimaryInstance",
        id = "currentAvatarStateId"
    )
    //    // Can't use with API v6 - generic "When plugin state changes" can be used for now
    //    @Event(name = "When Avatar State ID Changes (ID as Text)",
    //        format = "When Avatar State ID becomes \$val", id = "currentAvatarStateId"
    //    )
    private var stateCurrentAvatarStateId: String = "Not Connected"


    /**
     * Current Avatar State - Name
     */
    @State(
        desc = "Current Avatar State - Name",
        defaultValue = "Not Connected",
        categoryId = "PrimaryInstance",
        id = "currentAvatarStateName"
    )
    private var stateCurrentAvatarStateName: String = "Not Connected"


    /**
     * Current Avatar State - Thumbnail
     */
    @State(
        desc = "Current Avatar State - Thumbnail",
        defaultValue = "",
        categoryId = "PrimaryInstance",
        id = "currentAvatarStateThumbnail"
    )
    private var stateCurrentAvatarStateThumbnail: String = ""


    /**
     * Set Current Avatar State with State ID String in 'Name (ID)' Format
     */
    @Action(
        name = "Set Avatar State",
        format = "Set Avatar state to {\$choices\$}",
        categoryId = "PrimaryInstance",
        prefix = "Veadotube Mini",
        id = "setAvatarStateFromList"
    )
    private fun actionSetAvatarStateFromList(@Data(valueChoices = [""]) choices: Array<String>) {
        LOGGER.debug {
            "actionSetAvatarStateFromList: Set to '${choices[0]}'"
        }
        if (primaryConnection != null) {
            //Get State Object ID from String
            try {
                val newState = findAvatarFromStateString(primaryConnection!!, choices[0])

                if (newState != null)
                    primaryConnection?.send(channelNodes, VtRequest.createSetStateMini(newState.id))
                else
                    LOGGER.warn { "Avatar Choice not Found: ${choices[0]}" }
            } catch (_: Exception) {/* Do nothing */
            }
        }
    }

    /**
     * Set Current Avatar State ID
     *
     * Message from
     */
    @Action(
        name = "Set Avatar State by ID (Text)",
        format = "Set Avatar to State with ID {\$text\$}",
        categoryId = "PrimaryInstance",
        prefix = "Veadotube Mini",
        id = "setAvatarStateByID"
    )
    private fun actionSetAvatarStateByID(@Data text: String) {

        primaryConnection?.send(channelNodes, VtRequest.createSetStateMini(text.trim()))

        LOGGER.debug { "actionSetAvatarStateByID: Set Avatar to $text" }

    }

    /* Main Vars */

    /**
     * Veadotube Instance Manager
     *
     * Reads Veadotube Instance Directory,
     *  alerts supplied [InstancesListener] (this) of changes
     */
    private var instanceManager: InstancesManager? = null


    /**
     * Veadotube Instance Collection
     *
     * String = [InstanceID.toString] Value
     *
     * Instance = Map of [Instance.instanceConnectionID] vs Instance Objects
     *
     * Should be run in a Synchronized context
     */
    private val instanceMap = HashMap<String, LinkedHashMap<String, Instance>>()


    /**
     * Veadotube Connection Collection
     *
     * String - [InstanceID.toString] Value
     *
     * Connection - Connection Map [Connection].[Instance.name] vs [Connection]
     *
     * Should be run in a Synchronized context
     */
    private val collInstConnections =
        HashMap<String, LinkedHashMap<String, Connection>>()


    /**
     * Map of [Connection]s with related [VeadoConnectionData]
     *
     * Contains data collected from Connection
     *
     * Work on held objects with should be synchronized with the [Connection] to prevent issues.
     *
     */
    private val collConnectionData =
        HashMap<Connection, VeadoConnectionData>()


    /**
     * Oldest instance by Launch time
     *
     * Used to work out Primary Connection
     */
    private var oldestInstance: Instance? = null

    /**
     * Primary Connection
     *
     * Used for actions etc. that don't specify a Connection
     *
     * Is Connection of Oldest Instance by default, or a match
     */
    private var primaryConnection: Connection? = null


    /**
     * Creates an Avatar State String from a State
     *
     * In the format of "`name` (`id`)"
     *
     * @param state State to Generate String from
     */
    private fun avatarStateToString(state: VtState) =
        "${state.name} (${state.id})"

    /**
     * Creates an Avatar State String from a State Name and ID
     *
     * In the format of "`name` (`id`)"
     *
     * @param stateId ID to Generate String from
     * @param stateName Name to Generate String from
     */
    private fun avatarStateToString(stateId: String, stateName: String) =
        "$stateName ($stateId)"

    /**
     * Updates the Avatar States for a Connection/Veadotube Instance in
     *
     * @param connection Connection where List was updated
     */
    private fun onUpdateAvatarStateList(connection: Connection) {
        val choices: ArrayList<String> = ArrayList()
        val choicesId: ArrayList<String> = ArrayList()

        /* primary Instance Choices*/
        // Oldest ID is primary
        val oldestInstanceID: InstanceID? = oldestInstance?.id

        val collectionsStates: ArrayList<VtState>? =
            collConnectionData[connection]?.statesAll

        if (!collectionsStates.isNullOrEmpty()) {
            for (state in collectionsStates) {
                val stateString = avatarStateToString(state)
                LOGGER.trace { "updateAvatarState: Added Choice \"$stateString\"" }
                choices.add(stateString)
                choicesId.add(state.id)
            }
        }


        if (oldestInstanceID == connection.instance.id) {
            // Update State Choice for primary State Chooser
            sendChoiceUpdateCurrentAvatarState(choices)
        }

    }

    /** Dynamic State - Updated
     *
     * May be removed
     */
    private fun triggerAvatarUpdatedEvent(
        state: String = "Unknown",
        allowEmptyValue: Boolean = false,
        forceUpdate: Boolean = false
    ) {
        this.sendCreateState(
            /* categoryId = */ "CategoryVeadotube",
            /* stateId = */ "avatarStateUpdated",
            /* parentGroup = */ "Veadotube",
            /* description = */ "Avatar State Updated",
            /* value = */ state,
            /* allowEmptyValue = */ allowEmptyValue,
            /* forceUpdate = */ forceUpdate
        )
    }


    /**
     * Extracts the ID from an Avatar State String and returns the matched Avatar State
     *
     * Returns a [VtState] if a match is found, `null` if not
     */
    private fun findAvatarFromStateString(connection: Connection, avatarStateString: String): VtState? {
        // Default Format is "<Name> (<ID>)" where ID is the State ID

        val stateID = findAvatarIDFromStatusString(avatarStateString) ?: return null

        val matchedState = collConnectionData[connection]?.getStateByID(stateID)

        LOGGER.debug {
            if (matchedState != null) {
                "findAvatarFromStateString: State Matched -> '${matchedState.id}', '${matchedState.name}'"
            } else {
                "findAvatarFromStateString: State '$stateID' not matched"
            }
        }

        return matchedState
    }


    /**
     * Extracts the ID from an Avatar State String and returns value
     *
     * Returns the Extracted ID if a match is found, `null` if not
     */
    private fun findAvatarIDFromStatusString(avatarStateString: String): String? {
        // Default Format is "<Name> (<ID>)" where ID is the State ID

        val matches = avatarStateRegex.find(avatarStateString)

        if (matches == null)
            LOGGER.warn { "findAvatarIDFromStatusString: Invalid Avatar State String: '$avatarStateString'" }
        else
            LOGGER.debug { "findAvatarIDFromStatusString: Regex found -> Name='${matches.groups["name"]?.value}' ID='${matches.groups["id"]?.value}'" }

        return matches?.groups?.get("id")?.value

    }

    /* Actions */
    @Action(name = "Refresh Avatar State List", categoryId = "PrimaryInstance", prefix = "Veadotube Mini")
    fun refreshStateListAll() {
        LOGGER.info { "refreshStateListAll" }

        synchronized(collInstConnections) {
            //request update from all channels
            collInstConnections.values.flatMap { it.values }.forEach {
                it.send(channel = channelNodes, VtRequest.getListStateMini)
                it.send(channel = channelNodes, VtRequest.getPeekStateMini)
            }
        }

    }

    @Action(name = "Refresh Current Avatar State", categoryId = "PrimaryInstance", prefix = "Veadotube Mini")
    fun getAvatarStateAll() {
        LOGGER.info { "getAvatarStateAll triggered" }

        synchronized(collInstConnections) {
            //request update from all channels
            collInstConnections.values.flatMap { it.values }.forEach {
                LOGGER.debug { "getAvatarStateAll: send request triggered - channel $channelNodes; request ${VtRequest.getPeekStateMini}" }
                it.send(channel = channelNodes, VtRequest.getPeekStateMini)
            }
        }

    }

    /**
     * Carries out shutdown, makes sure everything closes gracefully
     */
    private fun shutdown() {

        if (pluginClosing.getAndSet(true)) {
            return
        }

        runCatching { instanceManager?.close() }
        runCatching { Connection.closeAll() }

        if (veadotubePlugin.isConnected) {
            veadotubePlugin.close(null)
        }
    }

    /* Call Backs */
    override fun onDisconnected(exception: Exception?) {
        LOGGER.trace {
            when (exception) {
                null ->
                    "onDisconnected received"

                else ->
                    "onDisconnected received - exception: $exception"
            }
        }

    }

    override fun onReceived(jsonMessage: JsonObject) {
        // For unmapped actions, etc.
        LOGGER.debug { "onReceived - unexpected: $jsonMessage." }
    }

    override fun onListChanged(tpListChangeMessage: TPListChangeMessage) {
        LOGGER.debug { "onListChanged - unexpected: ${tpListChangeMessage.listId};${tpListChangeMessage.instanceId};${tpListChangeMessage.actionId};${tpListChangeMessage.value};" }
    }

    override fun onInfo(tpInfoMessage: TPInfoMessage) {
        LOGGER.debug { "onInfo ${tpInfoMessage.status}; ${tpInfoMessage.settings}" }

        if (tpInfoMessage.status == "paired") {

            // Start Instance Manager - Watches Veadotube Instance Folder and sends events to the receiver
            LOGGER.trace { "Construct Instance Manager" }
            instanceManager = InstancesManager(this)


            //Initialize Avatar State Updated Event
            triggerAvatarUpdatedEvent()

            updateTPConnectionSettingInfo()
        }
    }

    private fun updatePrimaryConnection(primaryNameOverwriteUpdated: Boolean = false) {
        if (instanceMap.isEmpty()) {
            oldestInstance = null
            primaryConnection = null
            return
        }

        if (oldestInstance == null) {
            synchronized(instanceMap) {
                updateOldestInstance()
            }
        }

        synchronized(collInstConnections) {
            synchronized(instanceMap) {

                if (oldestInstance != null) {
                    if (primaryConnection?.isConnected != true) primaryConnection = null // primary is not connected

                    val needsUpdate = when {
                        primaryNameOverwriteUpdated -> true
                        primaryConnection == null -> true
                        (settingVeadoPrimaryInstanceNameOverride.isBlank() &&
                                primaryConnection?.instance != oldestInstance) -> true

                        (settingVeadoPrimaryInstanceNameOverride.isNotEmpty() &&
                                primaryConnection?.instance?.name?.contains(
                                    settingVeadoPrimaryInstanceNameOverride,
                                    ignoreCase = false
                                ) != true) -> true

                        else -> false
                    }

                    if (needsUpdate) {

                        if (settingVeadoPrimaryInstanceNameOverride.isNotEmpty()) {
                            // Primary Overwrite Name was Updated, Name is NOT empty

                            val newPrimaryConnection =
                                collInstConnections.values.flatMap { it.values }
                                    .filter {
                                        it.name.contains(
                                            settingVeadoPrimaryInstanceNameOverride,
                                            ignoreCase = false
                                        )
                                    }.minByOrNull { it.connectionTimeMillis }

                            if (newPrimaryConnection != null) {
                                when (newPrimaryConnection) {
                                    primaryConnection -> { // Not Null, but Same
                                        LOGGER.trace { "Primary Instance left as '${newPrimaryConnection.instance.server}'; '${newPrimaryConnection.instance.name}'" }
                                    }

                                    else -> { // Not Null & Different
                                        primaryConnection = newPrimaryConnection
                                        LOGGER.info { "Primary Instance Updated to '${newPrimaryConnection.instance.server}'; '${newPrimaryConnection.instance.name}'" }
                                    }
                                }
                                return
                            }

                            // Continues as newPrimaryConnection was null
                            LOGGER.info { "Unable to find a match the Instance Override: '$settingVeadoPrimaryInstanceNameOverride'" }
                        }


                        if (primaryConnection == null ||
                            (settingVeadoPrimaryInstanceNameOverride.isBlank() &&
                                    primaryConnection?.instance != oldestInstance)
                        ) {
                            // If no Override (or Override not matched) find oldest
                            val newPrimaryConnectionFallback =
                                collInstConnections[oldestInstance?.id?.toString()]?.values?.minByOrNull { it.connectionTimeMillis }

                            when {
                                newPrimaryConnectionFallback == null -> {
                                    primaryConnection = null
                                    LOGGER.info { "Unable to find a Primary Connection" }
                                }

                                newPrimaryConnectionFallback != primaryConnection -> {
                                    // Not Null & Different
                                    primaryConnection = newPrimaryConnectionFallback
                                    LOGGER.info { "Primary Instance Updated to '${newPrimaryConnectionFallback.instance.server}'; '${newPrimaryConnectionFallback.instance.name}'" }
                                }

                                else -> {
                                    // Not Null, but Same
                                    LOGGER.trace { "Primary Instance left as '${newPrimaryConnectionFallback.instance.server}'; '${newPrimaryConnectionFallback.instance.name}'" }
                                }
                            }

                        }
                    }

                }

            }
        }

        updateTPConnectionSettingInfo()
    }

    /**
     * Requests [stateCurrentAvatarStateId] from [primaryConnection]
     */
    private fun sendRequestCurrentStateThumbnail() = kotlin.runCatching {
        if (primaryConnection != null && stateCurrentAvatarStateId.isNotBlank()) {
            primaryConnection?.send(
                channel = channelNodes,
                requestData = VtRequest.createThumbnailStateMini(stateCurrentAvatarStateId)
            )
        }


    }

    private fun updateTPConnectionSettingInfo() {
        synchronized(collInstConnections) {
            // Update connected Instances Count
            val connectedInstanceCount = collInstConnections.values.flatMap { it.values }.count()

            this.sendSettingUpdate(
                VeadoTouchPluginConstants.Settings.SettingVeadoInstanceCount.NAME,
                connectedInstanceCount.toString(),
                false
            )

            // Update Default/Oldest Instance info
            val conn = primaryConnection

            if (conn != null) {

                this.sendSettingUpdate(
                    /* settingName = */ VeadoTouchPluginConstants.Settings.SettingVeadoPrimaryInstanceServer.NAME,
                    /* value = */       conn.server,
                    /* allowEmptyValue = */ false
                )

                this.sendSettingUpdate(
                    /* settingName = */ VeadoTouchPluginConstants.Settings.SettingVeadoPrimaryInstanceName.NAME,
                    /* value = */       conn.name,
                    /* allowEmptyValue = */ false
                )
            } else {
                this.sendSettingUpdate(
                    /* settingName = */ VeadoTouchPluginConstants.Settings.SettingVeadoPrimaryInstanceServer.NAME,
                    /* value = */       "Awaiting Connection to Veadotube",
                    /* allowEmptyValue = */ true
                )

                this.sendSettingUpdate(
                    /* settingName = */ VeadoTouchPluginConstants.Settings.SettingVeadoPrimaryInstanceName.NAME,
                    /* value = */       "Awaiting Connection to Veadotube",
                    /* allowEmptyValue = */ true
                )
            }
        }
    }

    override fun onBroadcast(tpBroadcastMessage: TPBroadcastMessage) {
        LOGGER.trace { "onBroadcast ${tpBroadcastMessage.event}; ${tpBroadcastMessage.type}; ${tpBroadcastMessage.pageName}" }
    }

    override fun onSettings(tpSettingsMessage: TPSettingsMessage) {
        LOGGER.debug { "onSettings ${tpSettingsMessage.settings}" }

        if (settingVeadoPrimaryInstanceNameOverrideExisting != settingVeadoPrimaryInstanceNameOverride) {
            settingVeadoPrimaryInstanceNameOverrideExisting = settingVeadoPrimaryInstanceNameOverride

            updatePrimaryConnection(true)
        }


        if (settingVeadoAutoRequestThumbnailExisting != settingVeadoAutoRequestThumbnail) {
            settingVeadoAutoRequestThumbnailExisting = settingVeadoAutoRequestThumbnail

            if (
                settingVeadoAutoRequestThumbnail.isNotBlank() && (
                        settingVeadoAutoRequestThumbnail.contains("en", ignoreCase = true) ||
                                settingVeadoAutoRequestThumbnail.contains("y", ignoreCase = true) ||
                                settingVeadoAutoRequestThumbnail.contains("tr", ignoreCase = true)
                        )
            ) {

                if (!settingVeadoAutoRequestThumbnailEnabled) {
                    settingVeadoAutoRequestThumbnailEnabled = true
                    //Send Peek request - when the reply is received, png will be checked, etc.
                    primaryConnection?.let { sendRequestStatePeek(it) }
                }

            } else {
                settingVeadoAutoRequestThumbnailEnabled = false
            }

        }

    }


    override fun onNotificationOptionClicked(tpNotificationOptionClickedMessage: TPNotificationOptionClickedMessage) {
        LOGGER.info { "onNotificationOptionClicked received" }
    }

    /* IInstancesReceiver Functions */
    /**
     * Instance Manager - New Instance found
     */
    override fun onInstanceStart(instance: Instance) {
        // Get Instance Set for Instance ID, create, add and return a new one if it doesn't exist
        // > For Mini, only one will exist where Name = Title
        // > Future Versions may have more than one

        instanceManager?.let {
            synchronized(it) {
                LOGGER.trace { "onInstanceStart: Instance: $instance}" }
                // Add Instance to Map
                synchronized(instanceMap) {
                    //Add to instanceMap
                    val map = instanceMap.getOrPut(instance.id.toString()) { LinkedHashMap() }
                    map[instance.instanceConnectionID] = instance

                    if (oldestInstance == null || instance.id.timestamp < (oldestInstance?.id?.timestamp
                            ?: Long.MIN_VALUE)
                    ) {
                        // Set with this instance of oldestInstance if null or current inst is older than current
                        oldestInstance = instance
                    }
                }

                // Create Connection and add to Connection Collection
                synchronized(collInstConnections) {
                    LOGGER.trace { "onInstanceStart: Construct Connection ${instance.server} ${instance.name}" }
                    val connMap = collInstConnections.getOrPut(instance.id.toString()) { LinkedHashMap() }

                    val newConnection = instance.connect(this)
                    connMap.put(newConnection.instance.name, newConnection)

                }

                updatePrimaryConnection()
            }
        }
    }


    /**
     * Instance Manager Event - Existing Instance Updated
     *
     * Usually a Name or Server IP change, requiring reconnection
     */
    override fun onInstanceChange(instance: Instance, oldInstance: Instance) {
        instanceManager?.let {
            synchronized(it) {
                LOGGER.debug { "onInstanceChange: run instanceConnectionCloseAndCleanup with ${oldInstance.server} ${oldInstance.name}" }
                instanceConnectionCloseAndCleanup(oldInstance)

                LOGGER.trace { "onInstanceChange: run OnConnect with ${instance.server} ${instance.name}" }
                onInstanceStart(instance)

                updatePrimaryConnection()
            }
        }
    }

    /**
     * Instance Manager Event - Existing Instance Closed
     */
    override fun onInstanceEnd(id: InstanceID) {
        instanceManager?.let { instanceManager ->
            synchronized(instanceManager) {
                LOGGER.trace { "onInstanceEnd: End $id" }

                instanceIdConnectionCloseAndCleanup(id)

                updatePrimaryConnection()
            }
        }
    }

    /**
     * Close and Cleanup all Instances/Connections linked to an InstanceID
     */
    private fun instanceConnectionCloseAndCleanup(instance: Instance) {
        LOGGER.trace { "instanceCloseAndCleanup: Close and cleanup instance ${instance.server} ${instance.name} " }

        // Remove connection from Collection and make sure connection is closed
        synchronized(collInstConnections) {

            collInstConnections[instance.id.toString()]?.get(instance.name)?.let {
                LOGGER.trace { "instanceConnectionCloseAndCleanup: Close Connection ${it.server} ${it.name}" }
                it.close()

                //Cleanup States
                cleanupConnectionStates(it)
            }
        }

        //Remove from Map
        synchronized(instanceMap) {
            LOGGER.trace { "instanceConnectionCloseAndCleanup: Remove Instance from Map ${instance.instanceConnectionID}" }
            instanceMap[instance.id.toString()]?.remove(instance.instanceConnectionID)
        }
    }

    private fun updateOldestInstance() {

        for (instMap in instanceMap.values) {
            val inst = instMap.values.first()
            if (oldestInstance == null || inst.id.timestamp < (oldestInstance?.id?.timestamp ?: Long.MIN_VALUE)) {
                // Set with this instance of oldestInstance if null or current inst is older than current
                oldestInstance = inst
            }
        }

    }

    /**
     * Close and Cleanup all Instances/Connections linked to an InstanceID
     */
    private fun instanceIdConnectionCloseAndCleanup(id: InstanceID) {
        LOGGER.trace { "instanceCloseAndCleanup: Close and cleanup instance $id " }

        // Remove connection from Collection and make sure connection is closed
        synchronized(collInstConnections) {
            collInstConnections.remove(id.toString())?.values?.forEach { connectionToEnd ->

                LOGGER.trace { "onInstanceEnd: Close Connection ${connectionToEnd.server} ${connectionToEnd.name}" }
                if (connectionToEnd == primaryConnection) {
                    // Clear Current State
                    sendStateClearCurrentAvatarState()
                    sendStateClearCurrentAvatarStateName()
                    sendStateClearCurrentAvatarStateThumbnail()
                    sendStateClearCurrentAvatarStateId()
                    sendChoiceClearCurrentAvatarState()
                }

                connectionToEnd.close()

                //Cleanup States
                cleanupConnectionStates(connectionToEnd)

            }

        }

        //Remove from Map
        synchronized(instanceMap) {
            instanceMap.remove(id.toString())

            //Check if oldest instance is Ended
            if (oldestInstance?.id == id) {
                oldestInstance = null
                //If oldest removed, try and find a replacement

                updateOldestInstance()

            }
        }
    }


    private fun cleanupConnectionStates(connection: Connection) {
        //Cleanup States

        collInstConnections[connection.instance.id.toString()]?.remove(connection.instance.name)

        collConnectionData.remove(connection)

    }

    /* ConnectionReceiver Functions */
    override fun onConnectionError(connection: Connection, error: ConnectionError) {
        // Veadotube Connection Error
        LOGGER.trace { "onConnectionError: Connection ${connection.connUri}, Error ${error.name}" }

        synchronized(collInstConnections) {
            //TODO Finish - Maybe get rid or auto-retries and have onConnectionError return a bool; true for retry false for close?
            if (error == ConnectionError.FailedToConnect) {
                // Maybe Retry
                LOGGER.debug { "onConnectionError: Connection ${connection.server}, Failed to Connect" }
                connection.close()
                instanceManager?.markInstanceFailed(connection.instance.id)
            } else if (error == ConnectionError.ExceededRetries) {
                // Tell Manager to clear from known list?
                LOGGER.debug { "onConnectionError: Connection ${connection.server}, Connect Retries Exceeded" }
                connection.close()
                instanceManager?.markInstanceFailed(connection.instance.id)
            }
            // Nothing else currently, connection should auto-retry several times before giving up

            if (collInstConnections[connection.instance.id.toString()]?.equals(connection) != true) {
                // If Connection is not in Collection, make sure it closes.
                // Otherwise, it will retry several times before giving up
                connection.close()
            }
        }


    }

    override fun onConnectionChange(connection: Connection, active: Boolean) {
        // Veadotube Connection Activated/Up or Deactivated/Down
        if (active) {
            /* Connection Marked active */

            synchronized(collInstConnections) {
                // Add to map
                val linked =
                    collInstConnections.getOrPut(connection.instance.id.toString()) { (LinkedHashMap()) }
                linked[connection.instance.name] = connection

                // Create ConnectionData
                collConnectionData[connection] = VeadoConnectionData(connection)

                // Request list of possible States
                sendRequestStateList(connection)

                // Request Current State
                sendRequestStatePeek(connection)

                // Start State Listener
                connection.send(
                    channel = channelNodes,
                    VtRequest.createListenStateMini(listenerToken)
                )
            }
        } else {
            /* Connection Marked inactive */
            synchronized(collInstConnections) {
                //Stop Listener
                try {
                    connection.send(
                        channel = channelNodes,
                        VtRequest.createUnlistenStateMini(listenerToken)
                    )
                } catch (_: Exception) {/*Ignore*/
                }

                cleanupConnectionStates(connection)
            }
        }

    }

    override fun onConnectionReceive(connection: Connection, message: ResultMessage) {
        // Receive message from Veadotube
        LOGGER.debug { "onConnectionReceive: -> Connection ${connection.connUri} from Channel ${message.channel} received ${message.event} Message" }

        when (message) {
            is ResultMessage.ResultMessageWithEntryList -> {
                // Result from request: `nodes:{"event": "list"}`
                // This returns the entries - e.g. stateEvents - avatar state.
                // These values are sent in other request types
                // Mini just uses stateEvents, so currently we just assume id = mini and type = stateEvents
                // instead of requesting them first but this might change with other versions (Full, etc)

                LOGGER.debug { "onConnectionReceive: Message List -> Entry List (${message.entries.count()} Items)" }

                for (entry in message.entries) {
                    LOGGER.trace { "onConnectionReceive: Message -> Entry > Type: ${entry.type}; ID: ${entry.id}; Name: ${entry.name}" }
                }
            }

            is ResultMessage.ResultMessageWithPayload -> {
                LOGGER.debug { "onConnectionReceive: Message Payload" }
                LOGGER.trace { "Message -> ID:   ${message.id}" }
                LOGGER.trace { "Message -> Type: ${message.type}" }
                LOGGER.trace { "Message -> Name: ${message.name}" }

                when (message.payload) {

                    is BleatkanStatePeek -> {
                        // Peek result - could be Peek Request, Listener, etc.
                        val payload = message.payload as BleatkanStatePeek
                        LOGGER.debug { "onConnectionReceive: Message Payload -> Peek (${payload.state})" }

                        processReceivedPayloadPeek(connection, payload)
                    }

                    is BleatkanStateList -> {
                        // List of States - Received in order that they appear in Program
                        val payload = message.payload as BleatkanStateList
                        LOGGER.debug { "onConnectionReceive: Message Payload -> State List (${payload.states.count()} Items)" }

                        processReceivedPayloadAvatarStateList(connection, payload)
                    }

                    is BleatkanStateThumbnail -> {
                        // Thumb result - thumbnail for an Avatar State
                        val payload = message.payload as BleatkanStateThumbnail
                        LOGGER.debug { "onConnectionReceive: Message Payload -> Thumbnail" }

                        processReceivedPayloadThumbnail(connection, payload)
                    }

                }
            }
        }
    }

    /**
     * Veadotube Connection Update - Message Received
     *
     * @param connection Connection providing update
     * @param payload State List Data Received
     */
    private fun processReceivedPayloadAvatarStateList(
        connection: Connection,
        payload: BleatkanStateList
    ) {

        LOGGER.debug { "processReceivedPayloadAvatarStateList: Update Collection Maps" }
        synchronized(connection) {
            // Add/Replace existing Lists/Maps
            collConnectionData[connection]?.updateStates(payload)

            onUpdateAvatarStateList(connection)
        }
    }


    /**
     * Call when Peek Message Received - updates State ID/Name, etc. and sends to Touch Portal
     *
     * We may not have the state name yet - if not, a State Request should be sent
     *
     * @param connection Connection providing update
     * @param payload State Peek Data Received
     */
    private fun processReceivedPayloadPeek(
        connection: Connection,
        payload: BleatkanStatePeek
    ) {
        LOGGER.trace { "Message -> Payload -> Event: ${payload.event}, State: ${payload.state}" }

        synchronized(connection) {
            // Update Current State
            val connData = collConnectionData[connection]

            if (connData != null) {

                //Update value, return if it nothing is updated (false) - possible if Peek requests are sent
                if (!connData.updateCurrentState(payload)) return

                val stateCurrent = connData.currentState

                sendStateUpdateCurrentAvatarStateId(payload.state)

                if (stateCurrent != null) {
                    //If we have the name, update to Touch Portal

                    sendStateUpdateCurrentAvatarState(stateCurrent)

                    //Name value
                    if (stateCurrent.name.isNullOrEmpty()) {
                        //If we don't have the name, send request for fresh state list
                        sendRequestStateList(connection)
                    } else {
                        try {
                            sendStateUpdateCurrentAvatarStateName(stateCurrent.name!!)
                        } catch (_: Exception) {/* Do nothing */
                        }
                    }

                    if (settingVeadoAutoRequestThumbnailEnabled) {
                        when (val png = stateCurrent.thumbnail?.png) {
                            null ->
                                sendRequestStateThumbnail(connection, stateCurrent.id)

                            else ->
                                sendStateUpdateCurrentAvatarStateThumbnail(png)
                        }
                    }
                }

            } else {
                LOGGER.debug { "updateCurrentAvatarStateId: couldn't find collConnectionData for ${connection.connUri}" }
            }
        }


    }

    /**
     * Call when Current State has updated - updates name and sends to Touch Portal
     *
     * e.g. State Names may have Changed, etc.
     *
     * May be obsolete
     */
    @Deprecated("Obsolete")
    private fun onCurrentStateNameUpdated(connection: Connection) {
        // Update current state name
        synchronized(connection) {

            //Get current State for Connection
            val currentState = collConnectionData[connection]?.currentState
            LOGGER.debug { "updateCurrentStateName: Got Current State $currentState" }

            if (currentState != null) {
                //If not null, send

                sendStateUpdateCurrentAvatarState(currentState)

                sendStateUpdateCurrentAvatarStateName(currentState.name ?: "Unknown")

            }
        }
    }


    private fun processReceivedPayloadThumbnail(connection: Connection, payload: BleatkanStateThumbnail) {
        LOGGER.trace { "Message -> Payload -> Event/State:  ${payload.event}; ${payload.state}" }
        LOGGER.trace { "Message -> Payload -> Height/Width: ${payload.height}/${payload.width}" }
        LOGGER.trace { "Message -> Payload -> PNG B64 Chars: ${payload.png.count()}" }


        val collData = collConnectionData[connection] ?: return

        // Update Thumbnail - May need to process image to make it square
        val updated: Boolean = collData.updateStateThumbnail(payload)

        collData.currentState.let { currState ->

            if (currState?.id == payload.state) {

                currState.thumbnail?.png?.let { png ->
                    if (updated || stateCurrentAvatarStateThumbnail != png) {
                        // If matches current state, update Touch Portal
                        sendStateUpdateCurrentAvatarStateThumbnail(png)
                    }
                }
            }
        }
    }


    /**
     * Token for Listener
     */
    private val listenerToken = "TpVtPlugin.ChangeState"

    /**
     * Nodes Channel - default channel used in Mini
     */
    private val channelNodes = "nodes"

    /**
     * Actions for updating the Current Avatar State in Touch Portal etc.
     *
     * State and State Name, etc
     *
     * @see stateCurrentAvatarState
     */
    private fun sendStateUpdateCurrentAvatarState(
        state: VtState,
        allowEmptyValue: Boolean = false,
        forceUpdate: Boolean = false
    ) {
        val stateString = avatarStateToString(state.id, state.name ?: "Unknown")
        stateCurrentAvatarState = stateString

        // Update State - do this first in case Plugin State is used for checks
        this.sendStateUpdate(
            VeadoTouchPluginConstants.PrimaryInstance.States.CurrentAvatarState.ID,
            stateString,
            /* allowEmptyValue = */ allowEmptyValue,
            /* forceUpdate = */ forceUpdate
        )

    }

    /**
     * Action for clearing the Current Avatar State in Touch Portal etc.
     *
     * State and State Name, etc
     *
     * @see stateCurrentAvatarState
     */
    private fun sendStateClearCurrentAvatarState() {
        stateCurrentAvatarState = ""

        // Update State - do this first in case Plugin State is used for checks
        this.sendStateUpdate(
            VeadoTouchPluginConstants.PrimaryInstance.States.CurrentAvatarState.ID,
            stateCurrentAvatarState,
        )

    }

    /**
     * Actions for updating the Current Avatar State ID in Touch Portal etc.
     *
     * State ID Only
     *
     * @see stateCurrentAvatarStateId
     */
    private fun sendStateUpdateCurrentAvatarStateId(
        stateID: String,
        allowEmptyValue: Boolean = false,
        forceUpdate: Boolean = false
    ) {
        stateCurrentAvatarStateId = stateID

        // Update State - do this first in case Plugin State is used for checks
        this.sendStateUpdate(
            /* stateId = */ VeadoTouchPluginConstants.PrimaryInstance.States.CurrentAvatarStateId.ID,
            /* value = */ stateCurrentAvatarStateId,
            /* allowEmptyValue = */ allowEmptyValue,
            /* forceUpdate = */ forceUpdate
        )

    }

    /**
     * Actions for clearing the Current Avatar State ID in Touch Portal etc.
     *
     * State ID Only
     *
     * @see stateCurrentAvatarStateId
     */
    private fun sendStateClearCurrentAvatarStateId() {
        stateCurrentAvatarStateId = ""

        // Update State - do this first in case Plugin State is used for checks
        this.sendStateUpdate(
            /* stateId = */ VeadoTouchPluginConstants.PrimaryInstance.States.CurrentAvatarStateId.ID,
            /* value = */ stateCurrentAvatarStateId,
            /* allowEmptyValue = */ true,
            /* forceUpdate = */ false
        )

    }


    /**
     * Actions for updating the Current Avatar State Name in Touch Portal etc.
     *
     * State Name Only
     *
     * @see stateCurrentAvatarStateName
     */
    private fun sendStateUpdateCurrentAvatarStateName(
        stateName: String,
        allowEmptyValue: Boolean = false,
        forceUpdate: Boolean = false
    ) {
        stateCurrentAvatarStateName = stateName

        // Update State - do this first in case Plugin State is used for checks
        this.sendStateUpdate(
            /* stateId = */ VeadoTouchPluginConstants.PrimaryInstance.States.CurrentAvatarStateName.ID,
            /* value = */ stateCurrentAvatarStateName,
            /* allowEmptyValue = */ allowEmptyValue,
            /* forceUpdate = */ forceUpdate
        )

    }

    private fun sendStateClearCurrentAvatarStateName() {
        stateCurrentAvatarStateName = ""

        // Update State - do this first in case Plugin State is used for checks
        this.sendStateUpdate(
            /* stateId = */ VeadoTouchPluginConstants.PrimaryInstance.States.CurrentAvatarStateName.ID,
            /* value = */ stateCurrentAvatarStateName,
            /* allowEmptyValue = */ true,
            /* forceUpdate = */ false
        )


    }

    /**
     * Actions for updating the Current Avatar State Thumbnail in Touch Portal etc.
     *
     * State Thumbnail Only
     *
     * @see stateCurrentAvatarStateName
     */
    private fun sendStateUpdateCurrentAvatarStateThumbnail(
        stateThumbnail: String,
        allowEmptyValue: Boolean = false,
        forceUpdate: Boolean = false
    ) {
        stateCurrentAvatarStateThumbnail = stateThumbnail

        // Update State
        this.sendStateUpdate(
            /* stateId = */ VeadoTouchPluginConstants.PrimaryInstance.States.CurrentAvatarStateThumbnail.ID,
            /* value = */ stateCurrentAvatarStateThumbnail,
            /* allowEmptyValue = */ allowEmptyValue,
            /* forceUpdate = */ forceUpdate
        )

    }

    /**
     * Actions for updating the Current Avatar State Thumbnail in Touch Portal etc.
     *
     * State Thumbnail Only
     *
     * @see stateCurrentAvatarStateName
     */
    private fun sendStateClearCurrentAvatarStateThumbnail() {
        stateCurrentAvatarStateThumbnail = ""

        // Update State
        this.sendStateUpdate(
            /* stateId = */ VeadoTouchPluginConstants.PrimaryInstance.States.CurrentAvatarStateThumbnail.ID,
            /* value = */ stateCurrentAvatarStateThumbnail,
            /* allowEmptyValue = */ true,
            /* forceUpdate = */ false
        )

    }


    /**
     * Actions for updating the Choices for [actionSetAvatarStateFromList] and [stateCurrentAvatarState] in Touch Portal
     *
     * @see actionSetAvatarStateFromList
     */
    private fun sendChoiceUpdateCurrentAvatarState(choices: ArrayList<String>) {
        LOGGER.trace { "sendChoiceUpdateCurrentAvatarState: Sending choices: $choices" }


        // Update State Choices
        val toTypedArray = choices.toTypedArray()

        this.sendChoiceUpdate(
            VeadoTouchPluginConstants.PrimaryInstance.Actions.SetAvatarStateFromList.Choices.ID,
            toTypedArray
        )
        //        //Disabled, Event removed for now
        //        this.sendChoiceUpdate(
        //            VeadoTouchPluginConstants.PrimaryInstance.Events.CurrentAvatarState.ID,
        //            toTypedArray
        //        )

    }


    /**
     * Actions for updating the Choices for [actionSetAvatarStateFromList] and [stateCurrentAvatarState] in Touch Portal
     *
     * @see actionSetAvatarStateFromList
     */
    private fun sendChoiceClearCurrentAvatarState() {
        LOGGER.trace { "sendChoiceUpdateCurrentAvatarState: Clearing Choices" }


        // Clear State Choices
        val toTypedArray = Array(1) { "" }

        this.sendChoiceUpdate(
            /* listId = */ VeadoTouchPluginConstants.PrimaryInstance.Actions.SetAvatarStateFromList.Choices.ID,
            /* values = */ toTypedArray,
            /* allowEmptyArrayValues = */ true
        )

        //        //Disabled, Event removed for now
        //        this.sendChoiceUpdate(
        //            /* listId = */ VeadoTouchPluginConstants.PrimaryInstance.Events.CurrentAvatarState.ID,
        //            /* values = */ toTypedArray,
        //            /* allowEmptyArrayValues = */ true
        //        )

    }


    /* Veado Requests */

    private fun sendRequestStateList(connection: Connection) = runCatching {
        connection.send(
            channel = channelNodes,
            requestData = VtRequest.getListStateMini
        )
    }

    private fun sendRequestStatePeek(connection: Connection) = runCatching {
        connection.send(
            channel = channelNodes,
            requestData = VtRequest.getPeekStateMini
        )
    }

    private fun sendRequestStateThumbnail(connection: Connection, stateID: String) = runCatching {
        connection.send(
            channel = channelNodes,
            requestData = VtRequest.createThumbnailStateMini(stateID)
        )
    }


}


